/*
 * Copyright (c)  2016-2019 https://www.thecoderscorner.com (Nutricherry LTD).
 * This product is licensed under an Apache license, see the LICENSE file in the top-level directory.
 *
 */

package com.thecoderscorner.menu.editorui.generator.arduino;

import com.thecoderscorner.menu.domain.MenuItem;
import com.thecoderscorner.menu.domain.state.MenuTree;
import com.thecoderscorner.menu.domain.util.MenuItemHelper;
import com.thecoderscorner.menu.pluginapi.CodeGenerator;
import com.thecoderscorner.menu.pluginapi.EmbeddedCodeCreator;
import com.thecoderscorner.menu.pluginapi.EmbeddedPlatform;
import com.thecoderscorner.menu.pluginapi.TcMenuConversionException;
import com.thecoderscorner.menu.pluginapi.model.BuildStructInitializer;
import com.thecoderscorner.menu.pluginapi.model.CodeVariableCppExtractor;
import com.thecoderscorner.menu.pluginapi.model.CodeVariableExtractor;
import com.thecoderscorner.menu.pluginapi.model.parameter.CodeConversionContext;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static com.thecoderscorner.menu.editorui.generator.arduino.MenuItemToEmbeddedGenerator.makeNameToVar;
import static com.thecoderscorner.menu.pluginapi.EmbeddedPlatform.EmbeddedLanguage;
import static java.lang.System.Logger.Level.ERROR;
import static java.lang.System.Logger.Level.INFO;
import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

public class ArduinoGenerator implements CodeGenerator {
    private final System.Logger logger = System.getLogger(getClass().getSimpleName());
    public static final String LINE_BREAK = System.getProperty("line.separator");
    public static final String TWO_LINES = LINE_BREAK + LINE_BREAK;

    public static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM)
            .withLocale(Locale.getDefault())
            .withZone(ZoneId.systemDefault());

    private static final String COMMENT_HEADER = "/*\n" +
            "    The code in this file uses open source libraries provided by thecoderscorner" + LINE_BREAK + LINE_BREAK +
            "    DO NOT EDIT THIS FILE, IT WILL BE GENERATED EVERY TIME YOU USE THE UI DESIGNER" + LINE_BREAK +
            "    INSTEAD EITHER PUT CODE IN YOUR SKETCH OR CREATE ANOTHER SOURCE FILE." + LINE_BREAK + LINE_BREAK +
            "    All the variables you may need access to are marked extern in this file for easy" + LINE_BREAK +
            "    use elsewhere." + LINE_BREAK +
            " */" + LINE_BREAK + LINE_BREAK;

    private static final String HEADER_TOP = "#ifndef MENU_GENERATED_CODE_H" + LINE_BREAK +
                                             "#define MENU_GENERATED_CODE_H" + LINE_BREAK + LINE_BREAK;
    private final ArduinoLibraryInstaller installer;
    private final ArduinoSketchFileAdjuster arduinoSketchAdjuster;
    private final EmbeddedPlatform embeddedPlatform;

    private Consumer<String> uiLogger = null;

    public ArduinoGenerator(ArduinoSketchFileAdjuster adjuster,
                            ArduinoLibraryInstaller installer,
                            EmbeddedPlatform embeddedPlatform) {
        this.installer = installer;
        this.arduinoSketchAdjuster = adjuster;
        this.embeddedPlatform = embeddedPlatform;
    }

    @Override
    public boolean startConversion(Path directory, List<EmbeddedCodeCreator> codeGenerators, MenuTree menuTree) {
        logLine("Starting Arduino generate: " + directory);

        boolean avrArch = embeddedPlatform.getLanguage() == EmbeddedLanguage.CPP_AVR;

        // get the file names that we are going to modify.
        String inoFile = toSourceFile(directory, ".ino");
        String cppFile = toSourceFile(directory, "_menu.cpp");
        String headerFile = toSourceFile(directory, "_menu.h");
        String projectName = directory.getFileName().toString();

        var generators = new ArrayList<EmbeddedCodeCreator>();
        generators.add(new ArduinoGlobalsCreator(avrArch));
        generators.addAll(codeGenerators);

        try {
            // Prepare the generator by initialising all the structures ready for conversion.
            String root = getFirstMenuVariable(menuTree);
            var allProps = generators.stream().flatMap(gen -> gen.properties().stream()).collect(Collectors.toList());
            CodeVariableExtractor extractor = new CodeVariableCppExtractor(
                    new CodeConversionContext(embeddedPlatform, root, allProps), avrArch
            );

            Collection<BuildStructInitializer> menuStructure = generateMenusInOrder(menuTree);
            generators.forEach(gen -> gen.initialise(root));

            // generate the source by first generating the CPP and H for the menu definition and then
            // update the sketch. Also, if any plugins have changed, then update them.
            generateHeaders(generators, menuTree, headerFile, menuStructure, extractor);
            generateSource(generators, cppFile, menuStructure, projectName, extractor);
            updateArduinoSketch(inoFile, projectName, menuTree);
            addAnyRequiredPluginsToSketch(generators, directory);

            // do a couple of final checks and put out warnings if need be
            checkIfUpToDateWarningNeeded();
            checkIfLegacyFilesAreOnPath(directory);

            logLine("Process has completed, make sure the code in your IDE is up-to-date.");
            logLine("You may need to close the project and then re-open it to pick up changes..");
        }
        catch(Exception e) {
            logLine("ERROR during conversion---------------------------------------------");
            logLine("The conversion process has failed with an error: " + e.getMessage());
            logLine("A more complete error can be found in the log file in <Home>/.tcMenu");
            logger.log(ERROR, "Exception caught while converting code: ", e);
        }

        return true;
    }

    private void checkIfLegacyFilesAreOnPath(Path directory) {
        if(Files.exists(Paths.get(toSourceFile(directory, ".h")))
                || Files.exists(Paths.get(toSourceFile(directory, ".cpp")))) {

            Path fileName = directory.getFileName();
            logLine("ERROR: OLD FILES FOUND !!!!!!!!!!==========================================");
            logLine("POTENTIAL COMPILE ERROR IN IDE - Non backward compatible change");
            logLine("From V1.2 onwards the source files containing menu definitions have changed");
            logLine("from " + fileName + ".h/.cpp to " + fileName + "_menu.h/_menu.cpp");
            logLine("To avoid errors in your IDE you will need to open the directory and remove");
            logLine("the files " + fileName + ".h/.cpp");
            logLine("Also remove the line #include <" + fileName + "_tcmenu.h> from your sketch" );
            logLine("The directory is: " + directory);
            logLine("===========================================================================");
        }
    }

    private void generateSource(List<EmbeddedCodeCreator> generators, String cppFile,
                                   Collection<BuildStructInitializer> menuStructure,
                                   String projectName, CodeVariableExtractor extractor) throws TcMenuConversionException {

        try (Writer writer = new BufferedWriter(new FileWriter(cppFile))) {
            logLine("Writing out source CPP file: " + cppFile);

            writer.write(COMMENT_HEADER);

            writer.write("#include <tcMenu.h>");
            writer.write(LINE_BREAK);
            writer.write("#include \"" + projectName + "_menu.h\"");

            writer.write(TWO_LINES + "// Global variable declarations" + TWO_LINES);
            writer.write(extractor.mapVariables(
                    generators.stream().flatMap(ecc->ecc.getVariables().stream()).collect(Collectors.toList())
            ));

            writer.write(TWO_LINES + "// Global Menu Item declarations" + TWO_LINES);
            writer.write(menuStructure.stream()
                    .map(extractor::mapStructSource)
                    .collect(Collectors.joining(LINE_BREAK)));

            writer.write(TWO_LINES + "// Set up code" + TWO_LINES);
            writer.write("void setupMenu() {" + LINE_BREAK);
            writer.write(extractor.mapFunctions(
                    generators.stream().flatMap(ecc->ecc.getFunctionCalls().stream()).collect(Collectors.toList())
            ));

            writer.write(LINE_BREAK + "}" + LINE_BREAK);
            writer.write(LINE_BREAK);

            logLine("Finished processing source file.");

        } catch (Exception e) {
            logLine("Failed to generate CPP: " + e.getMessage());
            throw new TcMenuConversionException("Header Generation failed", e);
        }

    }

    private void generateHeaders(List<EmbeddedCodeCreator> embeddedCreators, MenuTree menuTree,
                                    String headerFile, Collection<BuildStructInitializer> menuStructure,
                                    CodeVariableExtractor extractor) throws TcMenuConversionException {
        try (Writer writer = new BufferedWriter(new FileWriter(headerFile))) {
            logLine("Writing out header file: " + headerFile);

            writer.write(COMMENT_HEADER);
            writer.write(HEADER_TOP);

            // first get a list of includes to add to the header file from the creators
            var includeList = embeddedCreators.stream().flatMap(g -> g.getIncludes().stream()).collect(Collectors.toList());

            // now add any extra headers needed for the menu structure items.
            includeList.addAll(menuStructure.stream()
                    .flatMap(s-> s.getHeaderRequirements().stream())
                    .collect(Collectors.toList()));

            // and write out the includes
            writer.write(extractor.mapIncludes(includeList));

            writer.write(LINE_BREAK + LINE_BREAK + "// all define statements needed" + LINE_BREAK);

            // now get all the #defines that we need to add.
            writer.write(extractor.mapDefines());

            writer.write(LINE_BREAK + LINE_BREAK + "// all variables that need exporting" + LINE_BREAK);

            // and put the exports in the file too
            writer.write(extractor.mapExports(
                    embeddedCreators.stream().flatMap(ecc->ecc.getVariables().stream()).collect(Collectors.toList())
            ));
            writer.write(LINE_BREAK + LINE_BREAK + "// all menu item forward references." + LINE_BREAK);

            writer.write(menuStructure.stream()
                    .map(extractor::mapStructHeader)
                    .filter(item-> !item.isEmpty())
                    .collect(Collectors.joining(LINE_BREAK))
            );

            writer.write(TWO_LINES);

            writer.write("// Callback functions always follow this pattern: void CALLBACK_FUNCTION myCallback();"
                            + LINE_BREAK + "#define CALLBACK_FUNCTION" + LINE_BREAK + LINE_BREAK);

            for (String callback : callBackFunctions(menuTree)) {
                writer.write("void CALLBACK_FUNCTION " + callback + "(int id);" + LINE_BREAK);
            }

            writer.write(LINE_BREAK + "void setupMenu();" + LINE_BREAK);
            writer.write(LINE_BREAK + "#endif // MENU_GENERATED_CODE_H" + LINE_BREAK);

            logLine("Finished processing header file.");
        } catch (Exception e) {
            logLine("Failed to generate header file: " + e.getMessage());
            throw new TcMenuConversionException("Header Generation failed", e);
        }
    }

    private void checkIfUpToDateWarningNeeded() {
        if(!installer.statusOfAllLibraries().isUpToDate()) {
            logLine("WARNING===============================================================");
            logLine("The embedded libraries are not up-to-date, build problems are likely");
            logLine("Select ROOT menu item and choose update libraries from the editor");
            logLine("WARNING===============================================================");
        }
    }

    private void updateArduinoSketch(String inoFile, String projectName, MenuTree menuTree) throws TcMenuConversionException {
        logLine("Making adjustments to " + inoFile);

        try {
            arduinoSketchAdjuster.makeAdjustments(this::logLine, inoFile, projectName, callBackFunctions(menuTree));
        } catch (IOException e) {
            logger.log(ERROR, "Sketch modification failed", e);
            throw new TcMenuConversionException("Could not modify sketch", e);
        }
    }

    private void addAnyRequiredPluginsToSketch(List<EmbeddedCodeCreator> generators, Path directory) throws TcMenuConversionException {
        logLine("Finding any required rendering / remote plugins to add to project");

        AtomicReference<Exception> possibleException = new AtomicReference<>();

        generators.stream().flatMap(gen-> gen.getRequiredFiles().stream()).forEach(file -> {
            try {
                Path fileToCopy = installer.findLibraryInstall("tcMenu")
                        .orElseThrow(IOException::new).resolve(file);

                Path nameOfFile = Paths.get(file).getFileName();
                Files.copy(fileToCopy, directory.resolve(nameOfFile), REPLACE_EXISTING);
                logLine("Copied with replacement " + file);
            } catch (IOException e) {
                logLine("Copy failed for required plugin: " + file);
                possibleException.set(e);
            }
        });
        if(possibleException.get() != null) {
            throw new TcMenuConversionException("Plugin copy failed", possibleException.get());
        }
    }

    @Override
    public void setLoggerFunction(Consumer<String> uiLogger) {
        this.uiLogger = uiLogger;
    }

    private String getFirstMenuVariable(MenuTree menuTree) {
        return menuTree.getMenuItems(MenuTree.ROOT).stream().findFirst()
                .map(menuItem -> "menu" + makeNameToVar(menuItem.getName()))
                .orElse("");
    }

    private Collection<BuildStructInitializer> generateMenusInOrder(MenuTree menuTree) {
        List<MenuItem> root = menuTree.getMenuItems(MenuTree.ROOT);
        List<List<BuildStructInitializer>> itemsInOrder = renderMenu(menuTree, root);
        Collections.reverse(itemsInOrder);
        return itemsInOrder.stream()
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
    }

    private List<List<BuildStructInitializer>> renderMenu(MenuTree menuTree, Collection<MenuItem> itemsColl) {
        ArrayList<MenuItem> items = new ArrayList<>(itemsColl);
        List<List<BuildStructInitializer>> itemsInOrder = new ArrayList<>(100);
        for (int i = 0; i < items.size(); i++) {

            if (items.get(i).hasChildren()) {
                int nextIdx = i + 1;
                String nextSub = (nextIdx < items.size()) ? items.get(nextIdx).getName() : null;

                List<MenuItem> childItems = menuTree.getMenuItems(items.get(i));
                String nextChild = (!childItems.isEmpty()) ? childItems.get(0).getName() : null;
                itemsInOrder.add(MenuItemHelper.visitWithResult(items.get(i),
                        new MenuItemToEmbeddedGenerator(nextSub, nextChild)).orElse(Collections.emptyList()));
                itemsInOrder.addAll(renderMenu(menuTree, childItems));
            } else {
                int nextIdx = i + 1;
                String next = (nextIdx < items.size()) ? items.get(nextIdx).getName() : null;
                itemsInOrder.add(MenuItemHelper.visitWithResult(items.get(i),
                        new MenuItemToEmbeddedGenerator(next)).orElse(Collections.emptyList()));
            }
        }
        return itemsInOrder;
    }

    private List<String> callBackFunctions(MenuTree menuTree) {
        return menuTree.getAllSubMenus().stream()
                .flatMap(menuItem -> menuTree.getMenuItems(menuItem).stream())
                .filter(menuItem -> menuItem.getFunctionName() != null && !menuItem.getFunctionName().isEmpty())
                .map(MenuItem::getFunctionName)
                .collect(Collectors.toList());

    }

    private String toSourceFile(Path directory, String ext) {
        Path file = directory.getFileName();
        return Paths.get(directory.toString(), file.toString() + ext).toString();
    }

    private void logLine(String s) {
        if(uiLogger != null) uiLogger.accept(DATE_TIME_FORMATTER.format(Instant.now()) + " - " + s);
        logger.log(INFO, s);
    }
}
